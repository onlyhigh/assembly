어셈블리에서 조건 처리

-Boolean Operations (논리 연산)	
AND, OR, NOT 같은 연산을 사용하여 참/거짓 조건을 만든다.
IF Statements (조건문)	
-C 같은 고급 언어의 if 문이 어셈블리에서는 비교 명령 + 분기 명령으로 변환되어 동작한다.
-Bit Manipulation (비트 조작)	
값의 특정 비트를 설정, 클리어, 반전하는 방법을 배운다.
-Data Encryption (데이터 암호화)	
간단한 바이너리 조작을 통해 암호화의 기본 원리를 이해한다.
-Signed vs Unsigned Numbers (부호/무부호 차이)	
정수의 해석 방식이 조건 비교 결과에 영향을 미치므로, 부호 있는 수/없는 수 비교를 구분해야 한다.

논리 연산

명령어  의미	                            설명
AND	    논리 AND	                      두 값의 각 비트를 AND 연산 → 결과를 목적지에 저장
OR	    논리 OR	                        값의 각 비트를 OR 연산 → 결과를 목적지에 저장
XOR   	배타적 OR	                      두 값의 각 비트를 XOR 연산 → 서로 다르면 1, 같으면 0
NOT	    비트 반전	                      목적지의 비트를 모두 뒤집음 (0→1, 1→0)
TEST	  AND 연산 후 결과를 저장하지 않음	내부적으로 AND를 하되, 결과는 버리고 플래그(ZF 등) 만 설정 → 조건 분기에서 많이 사용

어셈블리에서 비교나 논리 연산을 하면 CPU 플래그 레지스터의 값이 바뀌는데,
이 플래그 값에 따라 JE, JG, JL 같은 분기(점프) 명령이 조건을 판단한다.

플래그	             의미	                                  설명
Zero Flag (ZF)	   결과가 0인지 확인	                      연산 결과가 0이면 ZF = 1, 아니면 0 → JE / JZ 같은 명령에서 사용
Carry Flag (CF)	   자리올림/자리내림 발생 여부	            무부호 정수에서 오버플로우 판단에 사용
Sign Flag (SF)	   결과의 부호	연산                        결과의 최상위 비트(MSB) → 1이면 음수, 0이면 양수 (2의 보수 표현 기준)
Overflow Flag (OF) 부호 있는 정수의 오버플로우 여부	        signed 계산에서 결과가 표현 범위를 벗어났는지 표시
Parity Flag (PF)	 결과의 하위 8비트에서 1의 개수가 짝수인지	짝수면 PF=1 → 일반적으로는 거의 사용 X

AND 명령은 특정 비트들을 0으로 만들고,
나머지 비트는 그대로 유지하기 위해 사용된다. (→ 비트 마스크)

✅ 특정 비트를 지우기(clear = 0으로 설정)  AND 명령은 항상 Overflow 플래그와 Carry 플래그를 0으로 만든다.
✅ 나머지 비트는 그대로 유지               그리고 Sign 플래그, Zero 플래그, Parity 플래그는 연산 결과에 따라 변경된다.
                                         즉: OF, CF → 무조건 꺼짐(0) // SF, ZF, PF → 결과값에 따라 달라짐

x	y	x AND y   x	y	x OR y   x	y	x XOR y
0	0	   0      0	0  	0      0	0	   0
0	1	   0      0	1  	1      0	1	   1
1	0	   0      1	0	  1      1	0	   1
1	1	   1      1	1  	1      1	1	   0

소문자 → 대문자 변환은 문자에서 5번째 비트를 0으로 만들면 된다. (AND 11011111b)

OR 명령은 두 값의 각 비트를 OR 연산하여 결과를 destination에 저장
특정 비트를 강제로 1로 설정하고 싶을 때 사용
(AND는 0으로 지우기, OR은 1로 만들기)

✅ Bit-Mapped Sets (비트로 표현된 집합)
하나의 정수를 비트(bit) 로 보고,
각 비트가 집합에 어떤 원소가 포함되어 있는지를 나타내는 방식.
이 예제에서 AND 명령 실행 후 Zero 플래그가 0(=결과가 0이 아님) 이면,
원소 [4] 는 SetX 집합에 포함되어 있음을 알 수 있다.

✅ Set Complement (집합의 보수)
집합에서 존재하는 원소 ↔ 존재하지 않는 원소를 반전하는 것
→ NOT 명령으로 모든 비트를 뒤집으면 됨.

✅ Set Intersection (집합의 교집합)
AND 명령은 두 집합의 공통된 원소만 남긴다.

✅ Set Union (집합의 합집합)
OR 명령은 두 집합의 원소를 모두 포함하는 집합을 만든다.

✅ XOR Instruction 요약
XOR는 배타적 OR 연산
→ 두 비트가 서로 다르면 1, 같으면 0.
XOR 명령은 Overflow(OF)와 Carry(CF) 플래그를 항상 0으로 만든다.
결과에 따라 Sign(SF), Zero(ZF), Parity(PF) 는 변경된다.

✅ Parity Flag (PF)란?
결과 값의 하위 8비트에서 1의 개수가 짝수인지 확인하는 플래그

1의 개수	Parity Flag 상태
짝수	PF = 1 (set)
홀수	PF = 0 (clear)
값을 바꾸지 않고 Parity(짝수/홀수 여부) 를 확인하는 쉬운 방법은
그 값에 0과 XOR 연산을 하는 것이다.
(XOR 0은 값이 변하지 않지만, PF는 갱신됨)

✅ NOT Instruction (NOT 명령)
NOT 명령은 피연산자의 모든 비트를 반전(invert) 시킨다.
0 → 1, 1 → 0

이 결과를 1의 보수 (one’s complement) 라고 부른다.
NOT 명령은 어떤 CPU 플래그도 영향을 주지 않는다.
(ZF, SF, CF, OF 등 모두 변하지 않음)
